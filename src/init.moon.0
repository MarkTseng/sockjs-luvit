--
-- SockJS server implemented in luvit
-- https://github.com/sockjs/sockjs-protocol for details
--

_G.JSON = require 'server/modules/json'

Math = require 'math'

--
-- augment Response.prototype with helper methods
--
require './response-helpers'

--
-- routes that every SockJS server must respond to
--
transport_handlers = {
  xhr_send: require './xhr-jsonp-send'
  jsonp_send: require './xhr-jsonp-send'
  xhr: require './xhr-polling'
  jsonp: require './jsonp-polling'
  xhr_streaming: require './xhr-streaming'
  websocket: require './websocket'
  htmlfile: require './htmlfile'
  eventsource: require './eventsource'
}
other_handlers = {
  options: require './options'
  chunking_test: require './chunking-test'
  iframe: require './iframe'
}

--
-- Session
--
Session = require './session'

--
-- collection of servers
--
servers = {}

return (root, options) ->

  -- register/unregister the server
  if root
    servers[root] = options
    return if not options
    -- default options
    setmetatable options, __index: {
      sockjs_url: 'http://sockjs.github.com/sockjs-client/sockjs-latest.min.js'
      heartbeat_delay: 25000
      disconnect_delay: 5000
      response_limit: 128 * 1024
      origins: {'*:*'}
      disabled_transports: {}
      cache_age: 365 * 24 * 60 * 60 -- one year
      get_nonce: () -> Math.random()
    }

  parse_url = require('url').parse
  import sub, gsub, match, gmatch, find, parse_query from require 'string'

  -- return request handler
  return (req, res, nxt) ->

    res.get_session = (sid) => Session.get sid
    res.create_session = (sid, options) => Session.get_or_create sid, options

    -- TODO: these preliminary steps should belong to another implicit layer
    res.req = req
    req.uri = parse_url req.url if not req.uri
    --
    --req.uri.query = parse_query req.uri.query

    path = req.uri.pathname
    -- strip trailing slash
    --path = sub(path, 1, -1) if sub(path, -1) == '/'
    p('REQUEST', req.method, req.url)

    --root, sid, transport = match path, '^(/.+)/[^./]+/([^./]+)/([a-z_]+)$'
    parts = { false, false, false, false }
    i = 0
    for v in gmatch(path, '/([^/]*)')
      i = i + 1
      parts[i] = v if v != ''
    p('???', parts)
    root, srv, sid, transport = unpack parts
    --p('???', root, sid, transport)

    -- no such server mounted
    options = servers['/' .. root]
    return nxt() if not options

    if sid and transport
      return res\e404() if find(sid, '.', 1, true) or find(srv, '.', 1, true)
      if req.method == 'OPTIONS'
        -- TODO: guard
        --return res\e404() if not transport in {'xhr_send', 'xhr', 'xhr_streaming'}
        other_handlers.options res, options
      else
        handler = transport_handlers[transport]
        return res\e404() if not handler
        handler = handler[req.method]
        return res\send 405 if not handler
        p('SESSION!', req.method, root, sid, transport)
        handler res, options, sid, transport
      return

    else if srv == 'chunking_test'
        handler = other_handlers.chunking_test[req.method]
        return res\send 405 if not handler
        p('CHUNKING')
        handler res, options
        return

    else if srv and match(srv, 'iframe[0-9-.a-z_]*%.html')
        handler = other_handlers.iframe[req.method]
        return res\e404() if not handler
        p('IFRAME')
        handler res, options
        return

    else if not srv
        p('ROOT', parts)
        return res\e404() if req.method != 'GET'
        res\send 200, 'Welcome to SockJS!\n', ['Content-Type']: 'text/plain; charset=UTF-8'
        return

    p('FALLEN BACK', req.url)
    res\e404()
    return
