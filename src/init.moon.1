--
-- SockJS server implemented in luvit
-- https://github.com/sockjs/sockjs-protocol for details
--

_G.JSON = require 'server/modules/json'

Math = require 'math'

--
-- augment Response.prototype with helper methods
--
require './response-helpers'

--
-- routes that every SockJS server must respond to
--
transport_handlers = {
  xhr_send: require './xhr-jsonp-send'
  jsonp_send: require './xhr-jsonp-send'
  xhr: require './xhr-polling'
  jsonp: require './jsonp-polling'
  xhr_streaming: require './xhr-streaming'
  websocket: require './websocket'
  htmlfile: require './htmlfile'
  eventsource: require './eventsource'
}
other_handlers = {
  options: require './options'
  chunking_test: require './chunking-test'
  iframe: require './iframe'
}

--
-- Session
--
Session = require './session'

--
-- collection of servers
--
servers = {}

return (root, options) ->

  -- register/unregister the server
  if root
    servers[root] = options
    return if not options
    -- default options
    setmetatable options, __index: {
      sockjs_url: 'http://sockjs.github.com/sockjs-client/sockjs-latest.min.js'
      heartbeat_delay: 25000
      disconnect_delay: 5000
      response_limit: 128 * 1024
      origins: {'*:*'}
      disabled_transports: {}
      cache_age: 365 * 24 * 60 * 60 -- one year
      get_nonce: () -> Math.random()
    }

  parse_url = require('url').parse
  import sub, gsub, match, gmatch, find, parse_query from require 'string'
  import normalize from require 'path'

  -- return request handler
  return (req, res, nxt) ->

    res.get_session = (sid) => Session.get sid
    res.create_session = (sid, options) => Session.get_or_create sid, options

    -- TODO: these preliminary steps should belong to another implicit layer
    res.req = req
    req.uri = parse_url req.url if not req.uri
    --
    --req.uri.query = parse_query req.uri.query

    -- strip trailing slash and get rid of '..'
    path = normalize req.uri.pathname
    path = sub(path, 1, -2) if sub(path, -1, -1) == '/'
    p('REQUEST', req.method, req.url)

    -- extract first part
    index = find path, '/', 2, true
    -- exact root requested -> serve greeting
    if not index
      p('ROOT?', parts)
      return res\e404() if not servers[path] or req.method != 'GET'
      res\send 200, 'Welcome to SockJS!\n', ['Content-Type']: 'text/plain; charset=UTF-8'
      return

    -- extract root
    root = sub path, 1, index - 1
    -- no such server mounted
    options = servers[root]
    return nxt() if not options

    -- extract path remainder
    path = sub path, index + 1

    p('???', root, path)

    if path == 'chunking_test'
      handler = other_handlers.chunking_test[req.method]
      return res\send 405 if not handler
      p('CHUNKING')
      handler res, options
      return

    if match(path, 'iframe[0-9-.a-z_]*%.html$')
      handler = other_handlers.iframe[req.method]
      return res\e404() if not handler
      p('IFRAME')
      handler res, options
      return

    sid, transport = match path, '^[^./]+/([^./]+)/([a-z_]+)$'

    if sid and transport
      if req.method == 'OPTIONS'
        -- TODO: guard
        --return res\e404() if not transport in {'xhr_send', 'xhr', 'xhr_streaming'}
        other_handlers.options res, options
      else
        handler = transport_handlers[transport]
        return res\e404() if not handler
        handler = handler[req.method]
        return res\send 405 if not handler
        p('SESSION!', req.method, root, sid, transport)
        handler res, options, sid, transport
      return

    p('FALLEN BACK', req.url)
    res\e404()
    return
