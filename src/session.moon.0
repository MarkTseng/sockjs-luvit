--
-- SockJS server implemented in luvit
-- https://github.com/sockjs/sockjs-protocol for details
--

EventEmitter = setmetatable {}, __index: require('emitter').meta
import set_timeout, clear_timer from require 'timer'
import encode, decode from JSON
Table = require 'table'

--
-- Transport abstraction
--
Transport = {
  CONNECTING: 0
  OPEN: 1
  CLOSING: 2
  CLOSED: 3
  closing_frame: (status, reason) ->
    'c' .. encode({status, reason})
}

--
-- Session -- bidirectional WebSocket-like channel between client and server
--

--
-- collection of registered sessions
--
sessions = {}

-- TODO: get rid in production
_G.s = () -> sessions
_G.f = () -> sessions = {}

class Session extends EventEmitter

  get: (sid) -> sessions[sid]

  get_or_create: (sid, options) ->
    session = Session.get sid
    session = Session(sid, options) if not session
    session

  --
  -- create new session
  --

  new: (@sid, options) =>

    -- setup options
    @heartbeat_delay = options.heartbeat_delay
    @disconnect_delay = options.disconnect_delay
    -- TODO: uuid
    @id = options.get_nonce()

    -- allocate buffer for outgoing messages
    @send_buffer = {}
    -- put this session in collection of sessions
    @ready_state = Transport.CONNECTING
    sessions[@sid] = self if @sid

    -- setup inactivity timeout
    @to_tref = set_timeout @disconnect_delay, @ontimeout, self

    -- setup one-time connection event
    @emit_connection_event = ->
      @emit_connection_event = nil
      options.onconnection self
    -- DEBUG
    _G.l = self

  --
  -- bind a connection to this session
  --

  bind: (conn) =>
    p('BIND', @sid, @id)

    -- can't bind more than one connection
    if @conn
      conn\send_frame Transport.closing_frame(2010, 'Another connection still open')
      return

    -- closing session rejects bindings
    if @ready_state == Transport.CLOSING
      p('STATEISCLOSING', @close_frame)
      conn\send_frame @close_frame
      if @to_tref
        clear_timer @to_tref
      @to_tref = set_timeout @disconnect_delay, @ontimeout, self
      return
    --
    p('DOREGISTER', @ready_state)
    -- bind connection
    @conn = conn
    conn.session = self
    -- when connection ends, unbind it
    conn\once 'closed', () ->
      p('CLOSEDEVENT')
      @unbind()
    conn\once 'end', () ->
      p('END')
      @unbind()
    conn\once 'error', (err) ->
      p('ERROR', err)
      --error(err)
      conn\finish()

    -- send the open frame
    if @ready_state == Transport.CONNECTING
      @conn\send_frame 'o', (err) ->
        p('SENT_O', err)
      -- and mark this session as open
      @ready_state = Transport.OPEN
      -- emit connection event asynchronously
      --set_timeout 0, () ->
      @emit_connection_event()

    -- reset incativity timeout
    if @to_tref
      clear_timer @to_tref
      @to_tref = nil

    -- try to flush pending outgoing messages
    @flush() if @conn

    return

  unbind: =>
    p('UNREGISTER', @sid, @id, not not @conn)
    if @conn
      @conn.session = nil
      @conn = nil
    if @to_tref
      clear_timer @to_tref
    @to_tref = set_timeout @disconnect_delay, @ontimeout, self
    @TO = 'TIMEOUTINUNREGISTER'
    return

  ontimeout: =>
    p('TIMEDOUT', @sid, @conn)
    if @to_tref
      clear_timer @to_tref
      @to_tref = nil
    if @ready_state != Transport.CONNECTING and @ready_state != Transport.OPEN and @ready_state != Transport.CLOSING
      error 'INVALID_STATE_ERR'
    if @conn
      error 'RECV_STILL_THERE'
    @ready_state = Transport.CLOSED
    @emit 'close'
    if @sid
      sessions[@sid] = nil
      @sid = nil
    return

  onmessage: (payload) =>
    p('<MESSAGE', payload)
    if @ready_state == Transport.OPEN
      p('MESSAGE', #payload < 128 and payload or #payload)
      @emit 'message', payload
    return

  flush: =>
    --p('INFLUSH', #@send_buffer)
    if #@send_buffer > 0
      messages = @send_buffer
      @send_buffer = {}
      @conn\send_frame 'a' .. encode(messages), (err) ->
        debug('SENT_FRAME', err)
    else
      p('TOTREF?', @TO, @to_tref)
      [==[if @to_tref
        clear_timer @to_tref
        @to_tref = nil
      heartbeat = ->
        p('INHEART', not not @conn)
        if @conn
          @conn\send_frame 'h'
          @to_tref = set_timeout @heartbeat_delay, heartbeat
          @TO = 'TIMEOUTINHEARTX'
        else
          @to_tref = nil
          @TO = 'TIMEOUTINHEARTDOWNED'
      @to_tref = set_timeout @heartbeat_delay, heartbeat
      @TO = 'TIMEOUTINHEART0'
      ]==]
    return

  close: (status = 1000, reason = 'Normal closure') =>
    return false if @ready_state != Transport.OPEN
    @ready_state = Transport.CLOSING
    @close_frame = Transport.closing_frame status, reason
    if @conn
      --@conn\send_frame @close_frame, () -> @conn\finish()
      @conn\send_frame @close_frame
      @conn\finish()
    return

  send: (payload) =>
    return false if @ready_state != Transport.OPEN
    -- TODO: booleans won't get stringified by concat
    Table.insert @send_buffer, type(payload) == 'table' and Table.concat(payload, ',') or tostring(payload)
    if @conn
      set_timeout 0, () -> @flush()
    true

return Session
